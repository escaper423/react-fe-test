이 문서에서는 과제를 진행한 방향과, 과제 진행 중 마주쳤던 문제상황에 대한 해결 방법을 적어 놓았습니다.

## 구조
가장 처음 봉착한 문제는 어떤 구조로 작성하느냐 였습니다. 먼저 페이지를 상단부분인 Header, 그리고 나머지 부분인 Body로 나누었고, 데이터 및 함수 블록으로 사용할
Block.js와 해당 블록을 장착할 슬롯으로 사용할 Slot.js로 나누었습니다. 간략하게 그림으로 표현하면 다음과 같습니다.
![image](https://user-images.githubusercontent.com/41889090/161425486-f15d8218-75f1-427d-b521-e6c44fea961d.png)

초기에는 Block, Slot을 모아놓은 컨테이너를 따로 분리하여 놓을 생각이었으나, 이 과제에서는 소스코드의 가독성을 떨어뜨리고, 데이터의 흐름을 복잡하게 만드는 결과를 
초래할 것이라 판단되어 Body에 붙여두었습니다. 소스코드 내에서는 다음과 같이 작성되어 있습니다.
![image](https://user-images.githubusercontent.com/41889090/161425766-a3eea67d-abf0-4e68-a817-2c621dba3ae8.png)


## 화면 구성
화면 상단에는 실행 버튼이 존재하는 Header를 두었고, 화면의 나머지 부분에는 각 블록들과 슬롯들이 존재하는 Body를 배치하였습니다.
특히 블록 컨테이너의 부분에는 블록들을 리스트의 형태로 나열해야 했기 때문에, 컨테이너 부분의 display를 flex로 설정하였고,
영상에서의 구현 상세와 맞추기 위해 flex-direction을 조절하였으며, 이외에 데이터들을 가운데로 정렬하기 위해 align-items 속성과 
justify-content 속성에 각각 center로 설정해 두었습니다.
  또한 <b>width가 850xp 아래로 줄어들 경우</b>, 각 슬롯들은 가로가 아닌 세로로 정렬되도록 하였습니다.

![image](https://user-images.githubusercontent.com/41889090/161426160-763b10ea-6c39-4441-a4f4-b4d027865d1b.png)

## 데이터 흐름
가장 애를 먹었던 부분입니다. 각 블록들의 데이터들은 Body내의 블록 컨테이너에서 관리하고 있으며, 이를 배열의 형태로 저장해 놓았습니다.
하지만 함수 수행에 쓸 데이터와 함수의 정보는 redux를 통해 전역 상태로써 관리되고 있습니다. 프로그램의 최상단에 존재하는 index.js에 redux store를 만들어 두었고
그 안에 객체의 형태로 슬롯에 포함된 데이터, 함수 및 결과값이 저장되게 됩니다.<br><br>
그리고 블록 컨테이너의 상태는 useState Hook을 사용하여 저장해 놓았으며, 이로 인해 실시간으로 변동이 생기는 경우 재렌더링 하여 화면에 리스트의 상태가 실시간으로 나타나게 됩니다.<br><br>각 슬롯을 담당하는 Slot에는 두 가지의 상태가 존재합니다. 하나는 드래그로 들어오는 블록의 타입이 슬롯의 타입과 맞는지의 여부를 표시하며, 다른 하나는 현재 슬롯에 장착된 내용을 저장하게 됩니다. redux의 전역 상태의 변화를 감지하기 위해 useSelector를 사용한 selector변수를 두었으며, 슬롯의 상태에 변화가 있는 경우, useEffect를 통해 실시간으로 화면에 표시될 내용을 바꾸게 됩니다.

![image](https://user-images.githubusercontent.com/41889090/161426817-f78a9716-9bd1-4bab-8b7b-9c53d248e075.png)
<br><br>
드래그와 관련된 이벤트는 react-dnd 라이브러리를 사용하여 구현하였습니다. 드래그 하는 요소의 타입을 "Block"으로 두었으며, 각 슬롯은 이 타입의 드래그 요소만 받아들이게 됩니다.

![image](https://user-images.githubusercontent.com/41889090/161427043-ccc5c00e-4a5d-4118-ba1a-03aea26a9a79.png)

canDrop에서는 각 슬롯에 맞는 요소가 들어오는지 검사하며, hover는 블록을 슬롯에 갖다댔을 때 올바른 데이터 타입인지에 따라 슬롯의 테두리를 변경합니다. drop은 실제로 슬롯에 데이터를 적재하는 기능을 수행합니다.<br><br>

Header에서는 실행하기 버튼이 구현되어 있습니다. 여기에도 useSelector를 사용하여, 실시간으로 redux의 전역 상태를 살핍니다. 데이터와 함수가 전역 상태에 모두 적재되면, isReady가 True값이 되어, 버튼이 활성화 되게 되는데, 이 상태에서 버튼을 클릭하면 결과 슬롯에 결과가 적재됩니다.

![image](https://user-images.githubusercontent.com/41889090/161427522-00cd90c9-fda1-48ad-adcc-cb73a0b9af78.png)

이 과제에서는 if-else문을 통해 함수를 수행하였으나, 데이터가 커지게 되면 다른 방법을 사용하는 것이 좋겠다는 생각이 들었습니다.<br><br>
그리고 어떤 이유에서인지, hover에 할당되어 있는 handleDrop 함수에서 현재 슬롯의 상태가 정상적으로 반영되지 않는 문제가 발생하였습니다. 이 때문에, 블록 컨테이너 리스트를 갱신할 때, 같은 요소가 추가되거나, 비어있는 요소가 추가되는 식의 오류가 생겨 진행에 애를 먹었습니다. 이를 해결하기 위해 임시로 슬롯 div에 onDrop 이벤트로 또 한번 묶어 실행하니, 정상적으로 동작은 하지만, 엄연히 같은 함수가 두 번 실행되는 것으로, 이는 확실히 문제가 있다고 여겨졌습니다.

![image](https://user-images.githubusercontent.com/41889090/161427703-4f3cb629-9a3a-42fa-bd7a-2c5a220a6f21.png)

블록 컨테이너에 블록을 추가하고 지우는 함수는 Body에 블록 컨테이너 데이터와 함께 구현되어 있습니다. 해당 과제에서는 슬롯이 용도별로 하나 씩 3개이므로, 이를 각 슬롯에 props의 형태로 전달하여 사용하게 하였습니다. 지울 때는 단순히 filter 함수를 통해 해당 요소만 지우도록 하였으나, 추가할 때는 함수 또는 데이터가 순서에 상관없이 추가될 수 있으므로, 별도의 정렬을 거치게 해놓았습니다. 함수의 구현은 아래와 같습니다.

![image](https://user-images.githubusercontent.com/41889090/161427858-19dcce94-8811-4e06-8c92-d037e0b78bd1.png)
